A
modern
computer
consists
of
one
or
more
processors
some
main
memory
disks
printers
a
keyboard
a
mouse
a
display
network
interfaces
and
various
other
devices
All
in
all
a
complex
systemoo
If
every
application
programmer
had
to
understand
how
all
these
things
work
in
detail
no
code
would
ever
get
written
Furthermore
managing
all
these
components
and
using
them
optimally
is
an
exceedingly
challenging
job
For
this
reason
computers
are
equipped
with
a
layer
of
software
called
the
operating
system
whose
job
is
to
provide
user
programs
with
a
better
simpler
cleaner
model
of
the
computer
and
to
handle
managing
all
the
resources
just
mentioned
Operating
systems
are
the
subject
of
this
book
Most
readers
will
have
had
some
experience
with
an
operating
system
such
as
Windows
Linux
FreeBSD
or
OS
X
but
appearances
can
be
deceiving
The
program
that
users
interact
with
usually
called
the
shell
when
it
is
text
based
and
the
GUI
which
is
pronounced
when
it
uses
icons
is
actually
not
part
of
the
operating
system
although
it
uses
the
operating
system
to
get
its
work
done
A
simple
overview
of
the
main
components
under
discussion
here
is
given
in
Fig
Here
we
see
the
hardware
at
the
bottom
The
hardware
consists
of
chips
boards
disks
a
keyboard
a
monitor
and
similar
physical
objects
On
top
of
the
hardware
is
the
software
Most
computers
have
two
modes
of
operation
kernel
mode
and
user
mode
The
operating
system
the
most
fundamental
piece
of
software
runs
in
kernel
mode
also
called
supervisor
mode
In
this
mode
it
has
The
user
interface
program
shell
or
GUI
is
the
lowest
level
of
user-mode
software
and
allows
the
user
to
start
other
programs
such
as
a
Web
browser
email
reader
or
music
player
These
programs
too
make
heavy
use
of
the
operating
system
The
placement
of
the
operating
system
is
shown
in
Fig
It
runs
on
the
bare
hardware
and
provides
the
base
for
all
the
other
software
An
important
distinction
between
the
operating
system
and
normal
software
is
that
if
a
user
does
not
like
a
particular
email
reader
he
is
free
to
get
a
different
one
or
write
his
own
if
he
so
chooses
he
is
not
free
to
write
his
own
clock
interrupt
handler
which
is
part
of
the
operating
system
and
is
protected
by
hardware
against
attempts
by
users
to
modify
it
This
distinction
however
is
sometimes
blurred
in
embedded
systems
may
not
have
kernel
or
interpreted
systems
as
systems
that
use
interpretation
not
hardware
to
separate
the
Also
in
many
systems
there
are
programs
that
run
in
user
mode
but
help
the
operating
system
or
perform
privileged
functions
For
example
there
is
often
a
program
that
allows
users
to
change
their
passwords
It
is
not
part
of
the
operating
system
and
does
not
run
in
kernel
mode
but
it
clearly
carries
out
a
sensitive
function
and
has
to
be
protected
in
a
special
way
In
some
systems
this
idea
is
carried
to
an
extreme
and
pieces
of
what
is
traditionally
considered
to
be
the
operating
The
architecture
instruction
set
memory
and
bus
structure
of
most
computers
at
the
machine-language
level
is
primitive
and
awkward
to
program
especially
for
To
make
this
point
more
concrete
consider
modern
SATA
Serial
ATA
hard
disks
used
on
most
computers
A
book
Anderson
describing
an
early
version
of
the
interface
a
programmer
would
have
to
know
to
use
the
disk—ran
over
pages
Since
then
the
interface
has
been
revised
multiple
times
and
is
more
complicated
than
it
was
in
Clearly
no
sane
programmer
would
want
to
deal
with
this
disk
at
the
hardware
level
Instead
a
piece
of
software
called
a
disk
driver
deals
with
the
hardware
and
provides
an
interface
to
read
and
write
disk
blocks
without
getting
into
the
details
Operating
systems
contain
many
drivers
for
controlling
devices
But
even
this
level
is
much
too
low
for
most
applications
For
this
reason
all
operating
systems
provide
yet
another
layer
of
abstraction
for
using
disks
files
Using
this
abstraction
programs
can
create
write
and
read
files
without
having
to
deal
with
the
messy
details
of
how
the
hardware
actually
works
This
abstraction
is
the
key
to
managing
all
this
complexity
Good
abstractions
turn
a
nearly
impossible
task
into
two
manageable
ones
The
first
is
defining
and

implementing
the
abstractions
The
second
is
using
these
abstractions
to
solve
the
problem
at
hand
One
abstraction
that
almost
every
computer
user
understands
is
the
file
as
mentioned
above
It
is
a
useful
piece
of
information
such
as
a
digital
photo
saved
email
message
song
or
Web
page
It
is
much
easier
to
deal
with
photos
emails
songs
and
Web
pages
than
with
the
details
of
SATA
or
other
disks
The
job
of
the
operating
system
is
to
create
good
abstractions
and
then
implement
and
manage
the
abstract
objects
thus
created
In
this
book
we
will
talk
a
lot
about
abstractions
They
are
one
of
the
keys
to
understanding
operating
systems
This
point
is
so
important
that
it
is
worth
repeating
in
different
words
With
all
due
respect
to
the
industrial
engineers
who
so
carefully
designed
the
Macintosh
hardware
is
ugly
Real
processors
memories
disks
and
other
devices
are
very
complicated
and
present
difficult
awkward
idiosyncratic
and
inconsistent
interfaces
to
the
people
who
have
to
write
software
to
use
them
Sometimes
this
is
due
to
the
need
for
backward
compatibility
with
older
hardware
Other
times
it
is
an
attempt
to
save
money
Often
however
the
hardware
designers
do
not
realize
or
care
how
much
trouble
they
are
causing
for
the
software
One
of
the
major
tasks
of
the
operating
system
is
to
hide
the
hardware
and
present
programs
and
their
programmers
with
nice
clean
elegant
consistent
abstractions
to
work
with
instead
Operating
systems
turn
the
ugly
into
the
beautiful
as
shown
in
Fig
Not
every
question
is
relevant
to
every
caching
situation
For
caching
lines
of
main
memory
in
the
CPU
cache
a
new
item
will
generally
be
entered
on
every
cache
miss
The
cache
line
to
use
is
generally
computed
by
using
some
of
the
high-order
bits
of
the
memory
address
referenced
For
example
with
4096
cache
lines
of
bytes
and
32
bit
addresses
bits
through
might
be
used
to
specify
the
cache
line
with
bits
0
to
5
the
byte
within
the
cache
line
In
this
case
the
item
to
remove
is
the
same
one
as
the
new
data
goes
into
but
in
other
systems
it
might
not
be
Finally
when
a
cache
line
is
rewritten
to
main
memory
if
it
has
been
modified
since
it
was
cached
the
place
in
memory
to
rewrite
it
to
is
uniquely
determined
by
the
address
in
question
Caches
are
such
a
good
idea
that
modern
CPUs
have
two
of
them
The
first
level
or
L1
cache
is
always
inside
the
CPU
and
usually
feeds
decoded
instructions
into
the
CPU’s
execution
engine
Most
chips
have
a
second
L1
cache
for
very
heavily
used
data
words
The
L1
caches
are
typically
16
KB
each
In
addition
there
is
often
a
second
cache
called
the
L2
cache
that
holds
several
megabytes
of
recently
used
memory
words
The
difference
between
the
L1
and
L2
caches
lies
in
the
timing
Access
to
the
L1
cache
is
done
without
any
delay
whereas
access
to
the
L2
cache
involves
a
delay
of
one
or
two
clock
cycles
On
multicore
chips
the
designers
have
to
decide
where
to
place
the
caches
In
Fig
a
single
L2
cache
is
shared
by
all
the
cores
This
approach
is
used
in
Intel
multicore
chips
In
contrast
in
Fig
1-8b
each
core
has
its
own
L2
cache
This
approach
is
used
by
AMD
Each
strategy
has
its
pros
and
cons
For
example
the
Intel
shared
L2
cache
requires
a
more
complicated
cache
controller
but
the
AMD
way
makes
keeping
the
L2
caches
consistent
more
difficult
Main
memory
comes
next
in
the
hierarchy
of
Fig
1-9
This
is
the
workhorse
of
the
memory
system
Main
memory
is
usually
called
RAM
Random
Access
Memory
Old-timers
sometimes
call
it
core
memory
because
computers
in
the
and
1960s
used
tiny
magnetizable
ferrite
cores
for
main
memory
They
hav
e
been
gone
for
decades
but
the
name
persists
Currently
memories
are
hundreds
of
megabytes
to
several
gigabytes
and
growing
rapidly
All
CPU
requests
that
cannot
be
satisfied
out
of
the
cache
go
to
main
memory
In
addition
to
the
main
memory
many
computers
have
a
small
amount
of
nonvolatile
random-access
memory
Unlike
RAM
nonvolatile
memory
does
not
lose
its
contents
when
the
power
is
switched
off
ROM
Read
Only
Memory
is
programmed
at
the
factory
and
cannot
be
changed
afterward
It
is
fast
and
inexpensive
On
some
computers
the
bootstrap
loader
used
to
start
the
computer
is
contained
in
ROM
Also
some
cards
come
with
ROM
for
handling
low-level
device
control
EEPROM
Electrically
Erasable
PROM
and
flash
memory
are
also
nonvolatile
but
in
contrast
to
ROM
can
be
erased
and
rewritten
However
writing
them
takes
orders
of
magnitude
more
time
than
writing
RAM
so
they
are
used
in
the
same
way
ROM
is
only
with
the
additional
feature
that
it
is
now
possible
to
correct
bugs
in
programs
they
hold
by
rewriting
them
in
the
field
